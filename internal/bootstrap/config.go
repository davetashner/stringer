package bootstrap

import (
	"bytes"
	"fmt"
	"path/filepath"
	"text/template"

	"github.com/davetashner/stringer/internal/config"
)

// configTemplateData holds the values used to render the config template.
type configTemplateData struct {
	GitHubEnabled    bool
	VulnEnabled      bool
	GitDepth         int
	GitSince         string
	LargeFileThresh  int
	LotteryThreshold int
	Collectors       map[string]bool // nil = use defaults
	FromWizard       bool
}

// defaultTemplateData returns template data with sensible defaults.
func defaultTemplateData(hasGitHub bool) configTemplateData {
	return configTemplateData{
		GitHubEnabled:    hasGitHub,
		VulnEnabled:      true,
		GitDepth:         1000,
		GitSince:         "90d",
		LargeFileThresh:  500,
		LotteryThreshold: 80,
	}
}

// templateDataFromWizard converts wizard results to template data.
func templateDataFromWizard(wr *WizardResult) configTemplateData {
	return configTemplateData{
		GitHubEnabled:    wr.Collectors["github"],
		VulnEnabled:      wr.Collectors["vuln"],
		GitDepth:         wr.GitDepth,
		GitSince:         wr.GitSince,
		LargeFileThresh:  wr.LargeFileThresh,
		LotteryThreshold: wr.LotteryThreshold,
		Collectors:       wr.Collectors,
		FromWizard:       true,
	}
}

// boolFn returns "true" or "false" for use in templates.
func boolFn(v bool) string {
	if v {
		return "true"
	}
	return "false"
}

// collectorEnabled checks if a collector is enabled, defaulting to true
// for non-wizard runs (where Collectors map is nil).
func collectorEnabled(data configTemplateData, name string) bool {
	if data.Collectors == nil {
		return true
	}
	return data.Collectors[name]
}

var templateFuncs = template.FuncMap{
	"bool":    boolFn,
	"enabled": collectorEnabled,
}

// configTemplate generates a commented .stringer.yaml with sensible defaults.
// The template conditionally enables/disables collectors and sets thresholds
// based on auto-detection or wizard selections.
var configTemplate = template.Must(template.New("config").Funcs(templateFuncs).Parse(`# Stringer configuration — generated by 'stringer init'
# See: stringer docs --help for full documentation

# Output format: beads (default), json, markdown, tasks
#   beads  — JSONL for 'bd import' (machine-readable issue tracking)
#   json   — structured JSON array
#   markdown — human-readable Markdown report
#   tasks  — flat task list format
# output_format: beads

# Maximum issues to output (0 = unlimited)
# max_issues: 0

# Beads-aware dedup: skip signals already tracked in .beads/ directory
# beads_aware: true

collectors:
  # Scans source code for TODO, FIXME, HACK, BUG, and XXX comments.
  # Each comment becomes an actionable signal with file location and context.
  todos:
    enabled: {{ bool (enabled . "todos") }}
    # error_mode: warn          # skip = ignore errors | warn = log and continue | fail = abort
    # min_confidence: 0.0       # 0.0-1.0, filter signals below this threshold
    # exclude_patterns:         # glob patterns to skip
    #   - "vendor/**"
    #   - "node_modules/**"

  # Analyzes git history for reverts, high-churn files, and stale branches.
  # Helps identify unstable code areas and abandoned work.
  gitlog:
    enabled: {{ bool (enabled . "gitlog") }}
    git_depth: {{ .GitDepth }}             # max commits to walk (higher = slower but more thorough)
    git_since: "{{ .GitSince }}"           # only analyze commits within this window (e.g. 90d, 6m, 1y)

  # Detects structural code issues: oversized files, missing test coverage,
  # and other patterns that indicate maintenance risk.
  patterns:
    enabled: {{ bool (enabled . "patterns") }}
    large_file_threshold: {{ .LargeFileThresh }}  # files above this many lines get flagged

  # Identifies knowledge silos — directories where a single contributor
  # owns most of the code. High lottery risk = what if they win the lottery?
  lotteryrisk:
    enabled: {{ bool (enabled . "lotteryrisk") }}
    lottery_risk_threshold: {{ .LotteryThreshold }}   # ownership percentage that triggers a signal
    # directory_depth: 3        # how many directory levels to analyze (1-10)
    # max_blame_files: 50       # cap on files to git-blame per directory (1-1000)
    # anonymize: auto           # auto = public repos show names | always | never

  # Imports open issues and PR review comments from GitHub.
  # Requires GITHUB_TOKEN environment variable.
  github:
    enabled: {{ bool .GitHubEnabled }}
    # include_prs: true         # include pull request signals
    # include_closed: false     # include closed issues/PRs
    # history_depth: "90d"      # how far back to look for closed items
    # comment_depth: 30         # max comments per issue/PR to analyze
    # max_issues_per_collector: 100  # cap total GitHub signals

  # Checks project dependencies for archived repos, staleness, and deprecation.
  # Works with Go modules, npm, pip, Cargo, Maven, Gradle, and NuGet.
  dephealth:
    enabled: {{ bool (enabled . "dephealth") }}

  # Scans dependencies for known vulnerabilities via OSV.dev.
  # Supports Go, npm, pip, Cargo, Maven, Gradle, and NuGet ecosystems.
  vuln:
    enabled: {{ bool .VulnEnabled }}
`))

// GenerateConfig renders and writes .stringer.yaml to the repo root.
// If wizard is non-nil, uses wizard selections; otherwise uses auto-detected defaults.
// Returns the Action taken ("created", "skipped").
func GenerateConfig(repoPath string, hasGitHub bool, force bool, wizard *WizardResult) (Action, error) {
	configPath := filepath.Join(repoPath, config.FileName)

	// Check if config already exists.
	if !force {
		if _, err := FS.Stat(configPath); err == nil {
			return Action{
				File:        config.FileName,
				Operation:   "skipped",
				Description: "already exists, use --force to regenerate",
			}, nil
		}
	}

	// Build template data from wizard results or defaults.
	var data configTemplateData
	if wizard != nil {
		data = templateDataFromWizard(wizard)
	} else {
		data = defaultTemplateData(hasGitHub)
	}

	// Render template.
	var buf bytes.Buffer
	if err := configTemplate.Execute(&buf, data); err != nil {
		return Action{}, fmt.Errorf("rendering config template: %w", err)
	}

	if err := FS.WriteFile(configPath, buf.Bytes(), 0o644); err != nil {
		return Action{}, fmt.Errorf("writing %s: %w", config.FileName, err)
	}

	desc := "created with wizard selections"
	if wizard == nil {
		if hasGitHub {
			desc = "created with github collector enabled"
		} else {
			desc = "created with github collector disabled"
		}
	}
	if force {
		desc = "regenerated (" + desc + ")"
	}

	return Action{
		File:        config.FileName,
		Operation:   "created",
		Description: desc,
	}, nil
}
