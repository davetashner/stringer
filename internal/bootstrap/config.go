package bootstrap

import (
	"bytes"
	"fmt"
	"path/filepath"
	"text/template"

	"github.com/davetashner/stringer/internal/config"
)

// configTemplate generates a commented .stringer.yaml with sensible defaults.
// The template conditionally enables/disables the github collector based on
// whether a GitHub remote was detected.
var configTemplate = template.Must(template.New("config").Parse(`# Stringer configuration â€” generated by 'stringer init'
# See: stringer docs --help for full documentation

# Output format: beads (default), json, markdown, tasks
# output_format: beads

# Maximum issues to output (0 = unlimited)
# max_issues: 0

# Beads-aware dedup: skip signals already tracked as beads issues
# beads_aware: true

collectors:
  todos:
    enabled: true
    # error_mode: warn  # skip | warn | fail
    # exclude_patterns:
    #   - "vendor/**"
    #   - "node_modules/**"

  gitlog:
    enabled: true
    # git_depth: 1000
    # git_since: "90d"

  patterns:
    enabled: true
    # large_file_threshold: 500

  lotteryrisk:
    enabled: true
    # lottery_risk_threshold: 80
    # directory_depth: 3
    # max_blame_files: 50
    # anonymize: auto  # auto | always | never

  github:
    enabled: {{ .GitHubEnabled }}
    # include_prs: true
    # include_closed: false
    # history_depth: "90d"
    # comment_depth: 30
    # max_issues_per_collector: 100

  dephealth:
    enabled: true
`))

// GenerateConfig renders and writes .stringer.yaml to the repo root.
// Returns the Action taken ("created", "skipped").
func GenerateConfig(repoPath string, hasGitHub bool, force bool) (Action, error) {
	configPath := filepath.Join(repoPath, config.FileName)

	// Check if config already exists.
	if !force {
		if _, err := FS.Stat(configPath); err == nil {
			return Action{
				File:        config.FileName,
				Operation:   "skipped",
				Description: "already exists, use --force to regenerate",
			}, nil
		}
	}

	// Render template.
	var buf bytes.Buffer
	data := struct {
		GitHubEnabled bool
	}{
		GitHubEnabled: hasGitHub,
	}
	if err := configTemplate.Execute(&buf, data); err != nil {
		return Action{}, fmt.Errorf("rendering config template: %w", err)
	}

	if err := FS.WriteFile(configPath, buf.Bytes(), 0o644); err != nil {
		return Action{}, fmt.Errorf("writing %s: %w", config.FileName, err)
	}

	var desc string
	if hasGitHub {
		desc = "created with github collector enabled"
	} else {
		desc = "created with github collector disabled"
	}
	if force {
		desc = "regenerated (" + desc + ")"
	}

	return Action{
		File:        config.FileName,
		Operation:   "created",
		Description: desc,
	}, nil
}
