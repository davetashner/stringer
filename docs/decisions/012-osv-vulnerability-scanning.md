# 012: OSV-Based Multi-Ecosystem Vulnerability Scanning

**Status:** Accepted
**Date:** 2026-02-09
**Context:** stringer-uf1 (C7: Vulnerability Scanner Collector). Extending C7 beyond Go to support Java (Maven/Gradle) and future ecosystems.

## Problem

C7 is scoped to Go only, using `govulncheck` to scan `go.mod` dependencies. To support Java (and eventually Python, Node.js, Rust, C#), we need a vulnerability data source that covers multiple ecosystems without requiring each language's toolchain to be installed.

The key question: should each ecosystem get its own vulnerability backend, or should we use a single cross-ecosystem vulnerability database?

## Options

### Option A: Per-ecosystem tools (govulncheck, OWASP Dependency-Check, npm audit, etc.)

Each ecosystem uses its native vulnerability scanner.

**Pros:**
- Deepest integration per ecosystem (e.g., govulncheck does call-graph analysis for Go)
- Uses each community's canonical vulnerability data
- Battle-tested tools with established trust

**Cons:**
- Requires each language's toolchain installed on the scanning machine
- Each tool has different output formats, severity scales, and error modes — N integration layers
- OWASP Dependency-Check for Java requires downloading the NVD database (~2 GB, slow first run)
- Doesn't match stringer's zero-external-tooling philosophy (except git)
- Maintenance burden scales linearly with ecosystem count

### Option B: OSV.dev as single vulnerability backend

Use Google's Open Source Vulnerabilities database (osv.dev) via its Go client library (`google.golang.org/osv`). OSV covers Maven, PyPI, npm, crates.io, NuGet, Go, and more from a single API.

**Pros:**
- One integration covers all ecosystems — add a language by adding dependency parsing, not a new vuln backend
- No language toolchain required — only needs network access to osv.dev (or a local mirror)
- Go client library available (`google.golang.org/osv`) with batch query support
- Consistent response format: OSVID, aliases (CVE/GHSA), affected version ranges, fix versions
- Covers the Go vulnerability database (same data govulncheck uses, minus call-graph analysis)
- Free, open, well-maintained by Google

**Cons:**
- No call-graph analysis — reports vulnerabilities at the dependency level, not whether your code actually calls the vulnerable function (Go-specific loss vs. govulncheck)
- Requires network access (stringer currently works fully offline except for GitHub collector and dephealth)
- OSV severity data varies by ecosystem — some entries lack CVSS scores
- Single point of failure for all vulnerability data

### Option C: OSV primary, govulncheck enrichment for Go

Use OSV.dev for all ecosystems. For Go specifically, optionally run govulncheck as an enrichment pass to add call-graph analysis (whether the vulnerable function is actually called).

**Pros:**
- Best of both worlds — broad ecosystem coverage + deep Go analysis when available
- govulncheck enrichment is optional — graceful degradation already planned in C7.3
- Clear separation: OSV provides the vulnerability data, govulncheck provides Go-specific call-graph insight
- Incremental path — ship OSV-only first, add govulncheck enrichment later

**Cons:**
- Two code paths for Go (OSV + optional govulncheck)
- Marginal complexity increase vs. Option B
- govulncheck enrichment may not justify its cost if OSV data is sufficient

## Recommendation

**Option B: OSV.dev as single vulnerability backend.**

Option C is the ideal end state, but the govulncheck enrichment adds complexity without clear user demand. Start with Option B — it delivers multi-ecosystem vulnerability scanning (Go, Java, Python, Node.js, Rust, C#) from a single integration. If users request call-graph-level precision for Go, add govulncheck enrichment as a follow-up.

### Implementation plan

**Dependency parsing (per ecosystem):**

| Ecosystem | File | Parsing approach |
|-----------|------|------------------|
| Go | `go.mod` | `golang.org/x/mod/modfile.Parse` (already used by dephealth) |
| Java/Kotlin/Scala | `pom.xml` | `encoding/xml` — extract `<groupId>:<artifactId>:<version>` |
| Java/Kotlin/Scala | `build.gradle(.kts)` | Regex for `implementation`, `api`, `compile` dependency declarations |
| Python | `requirements.txt` | Line-based parsing (`package==version`) |
| Node.js | `package-lock.json` | JSON parsing for resolved versions |
| Rust | `Cargo.lock` | TOML parsing for `[[package]]` entries |
| C# | `*.csproj` | XML parsing for `<PackageReference>` elements |

**OSV integration:**
- Use `google.golang.org/osv` Go client for batch queries
- Group dependencies by ecosystem, query OSV in batches of 1000 (API limit)
- Cache results per scan to avoid redundant queries for shared transitive deps

**Signal emission:**
- Kind: `vulnerable-dependency`
- Title: `CVE-YYYY-NNNNN: <summary>` (or GHSA ID if no CVE)
- Description: affected versions, fix version, OSV URL
- FilePath: manifest file path (`go.mod`, `pom.xml`, etc.)
- Confidence: critical/high = 0.95, medium = 0.8, low = 0.6 (same as C7.2 spec)
- Tags: `[security, <ecosystem>]`

**Graceful degradation:**
- Network unreachable → warn + zero signals (per C7.3)
- No manifest file found for an ecosystem → skip silently
- OSV returns no data for a package → skip (not an error)

**Phased delivery:**
1. Go + Java (Maven) — validates the OSV approach with two ecosystems
2. Gradle, Python, Node.js — incremental manifest parsers
3. Rust, C# — complete ecosystem coverage

**Files affected:** ~3 new source files, ~3 new test files, ~400-500 lines.

## Decision

Option B accepted. OSV.dev as single vulnerability backend for all ecosystems. Supersedes the govulncheck-specific tasks C7.1–C7.3, which are closed in favor of C7.4–C7.8.
