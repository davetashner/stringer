name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read
  pull-requests: write

jobs:
  test:
    name: Test (Go ${{ matrix.go-version }})
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        go-version: ["1.24", "1.25"]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v6
        with:
          go-version: ${{ matrix.go-version }}
      - run: go build ./...
      - run: go test -race -count=1 ./...

  vet:
    name: Vet
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v6
        with:
          go-version: "1.25"
      - run: go vet ./...

  fmt:
    name: Format
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v6
        with:
          go-version: "1.25"
      - name: Check gofmt
        run: |
          unformatted=$(gofmt -l .)
          if [ -n "$unformatted" ]; then
            echo "Files not formatted:"
            echo "$unformatted"
            exit 1
          fi

  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v6
        with:
          go-version: "1.25"
      - uses: golangci/golangci-lint-action@v9
        with:
          version: latest

  tidy:
    name: Tidy
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v6
        with:
          go-version: "1.25"
      - run: go mod tidy
      - name: Check for changes
        run: git diff --exit-code go.mod

  coverage:
    name: Coverage
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v6
        with:
          go-version: "1.25"
      - name: Run tests with coverage
        run: go test -race -count=1 -coverprofile=coverage.out ./...
      - name: Check coverage threshold
        run: |
          total=$(go tool cover -func=coverage.out | grep total | awk '{print substr($3, 1, length($3)-1)}')
          echo "Total coverage: ${total}%"
          threshold=90
          if [ "$(echo "$total < $threshold" | bc)" -eq 1 ]; then
            echo "::error::Coverage ${total}% is below threshold ${threshold}%"
            exit 1
          fi

  vulncheck:
    name: Vulncheck
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v6
        with:
          go-version: "1.25"
      - uses: golang/govulncheck-action@v1

  binary-size:
    name: Binary Size
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v6
        with:
          go-version: "1.25"
      - name: Build binary
        run: go build -o stringer ./cmd/stringer
      - name: Check binary size
        run: |
          size=$(stat --format=%s stringer)
          baseline=$(cat .github/binary-size-baseline)
          max=$((baseline * 2))
          echo "Binary size: ${size} bytes"
          echo "Baseline:    ${baseline} bytes"
          echo "Max allowed: ${max} bytes (2x baseline)"
          if [ "$size" -gt "$max" ]; then
            echo "::error::Binary size ${size} exceeds 2x baseline ${baseline} (max: ${max})"
            exit 1
          fi
          echo "Binary size is within limits."

  commit-lint:
    name: Commit Lint
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Validate conventional commits
        run: |
          # Check all commits in the PR
          base="${{ github.event.pull_request.base.sha }}"
          head="${{ github.event.pull_request.head.sha }}"
          pattern='^(feat|fix|chore|docs|test|refactor|style|perf|ci|build|revert)(\(.+\))?!?: .+'
          failed=0
          while IFS= read -r msg; do
            # Skip merge commits
            if echo "$msg" | grep -qE '^Merge '; then
              continue
            fi
            if ! echo "$msg" | grep -qE "$pattern"; then
              echo "::error::Invalid commit message: $msg"
              echo "  Expected format: <type>: <description>"
              echo "  Valid types: feat, fix, chore, docs, test, refactor, style, perf, ci, build, revert"
              failed=1
            fi
          done < <(git log --format=%s "$base".."$head")
          if [ "$failed" -eq 1 ]; then
            exit 1
          fi
          echo "All commit messages follow conventional commits format."

  breaking-change-guard:
    name: Breaking Change Guard
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Check for breaking changes
        run: |
          base="${{ github.event.pull_request.base.sha }}"
          head="${{ github.event.pull_request.head.sha }}"
          found=0
          while IFS= read -r sha; do
            subject=$(git log -1 --format=%s "$sha")
            body=$(git log -1 --format=%b "$sha")
            # Check for ! marker in subject (e.g., feat!: or feat(scope)!:)
            if echo "$subject" | grep -qE '^(feat|fix|chore|docs|test|refactor|style|perf|ci|build|revert)(\(.+\))?!:'; then
              echo "::error::Breaking change detected in commit $sha: $subject"
              found=1
            fi
            # Check for BREAKING CHANGE in body/footer
            if echo "$body" | grep -qE '^BREAKING CHANGE:'; then
              echo "::error::Breaking change footer detected in commit $sha: $subject"
              found=1
            fi
          done < <(git rev-list "$base".."$head")
          if [ "$found" -eq 1 ]; then
            echo ""
            echo "Breaking changes require a major version bump."
            echo "If this is intentional, coordinate with the maintainer before merging."
            exit 1
          fi
          echo "No breaking changes detected."

  go-generate:
    name: Go Generate
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v6
        with:
          go-version: "1.25"
      - name: Run go generate
        run: go generate ./...
      - name: Check for uncommitted changes
        run: |
          if ! git diff --quiet; then
            echo "::error::Generated files are out of date. Run 'go generate ./...' and commit the changes."
            git diff --stat
            exit 1
          fi
          echo "Generated files are up to date."

  license-check:
    name: License Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v6
        with:
          go-version: "1.25"
      - name: Install go-licenses
        run: go install github.com/google/go-licenses@v1.6.0
      - name: Check licenses
        run: |
          # Check that all dependencies use allowed licenses
          allowed="Apache-2.0,BSD-2-Clause,BSD-3-Clause,MIT,ISC,MPL-2.0"
          go-licenses check ./... --allowed_licenses="$allowed" 2>&1 || {
            echo "::error::License compliance check failed. Some dependencies use disallowed licenses."
            echo "Allowed licenses: $allowed"
            echo ""
            echo "Run 'go-licenses report ./...' locally for details."
            exit 1
          }
          echo "All dependency licenses are compliant."

  archived-deps:
    name: Archived Deps Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v6
        with:
          go-version: "1.25"
      - name: Check for archived dependencies
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Checking dependencies for archived/EOL repositories..."

          # Get all module dependencies, filter to GitHub-hosted ones
          deps=$(go list -m -json all 2>/dev/null | \
            jq -r 'select(.Path != null) | .Path' | \
            grep '^github\.com/' | \
            sort -u)

          found_archived=0
          for mod_path in $deps; do
            # Extract owner/repo from module path (first two path segments after github.com)
            owner_repo=$(echo "$mod_path" | cut -d'/' -f2,3)

            # Skip if we can't parse owner/repo
            if [ -z "$owner_repo" ] || ! echo "$owner_repo" | grep -q '/'; then
              continue
            fi

            # Query GitHub API for archived status
            archived=$(gh api "repos/${owner_repo}" --jq '.archived' 2>/dev/null || echo "unknown")

            if [ "$archived" = "true" ]; then
              echo "::warning::Archived dependency: ${mod_path} (https://github.com/${owner_repo})"
              found_archived=1
            fi
          done

          if [ "$found_archived" -eq 1 ]; then
            echo ""
            echo "Some dependencies use archived repositories."
            echo "Consider finding maintained alternatives."
          else
            echo "No archived dependencies found."
          fi
          # Always succeed — this is a warning-only check
          exit 0

  pr-size-guard:
    name: PR Size Guard
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    env:
      PR_SIZE_WARN: ${{ vars.PR_SIZE_WARN || '500' }}
      PR_SIZE_FAIL: ${{ vars.PR_SIZE_FAIL || '1000' }}
    steps:
      - uses: actions/checkout@v4
      - name: Check PR size
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          pr_number="${{ github.event.pull_request.number }}"
          repo="${{ github.repository }}"

          # Get per-file diff stats, excluding test files
          total=0
          additions=0
          deletions=0
          while IFS= read -r line; do
            file=$(echo "$line" | jq -r '.filename')
            # Skip test files — they don't count against PR size
            case "$file" in
              *_test.go|*_test.ts|*_test.js|*.test.*|*.spec.*)
                continue
                ;;
            esac
            a=$(echo "$line" | jq '.additions')
            d=$(echo "$line" | jq '.deletions')
            additions=$((additions + a))
            deletions=$((deletions + d))
          done < <(gh api "repos/${repo}/pulls/${pr_number}/files" --paginate --jq '.[] | {filename, additions, deletions}' | jq -c '.')
          total=$((additions + deletions))

          echo "PR #${pr_number}: +${additions} -${deletions} = ${total} lines changed"
          echo "Warn threshold: ${PR_SIZE_WARN} lines"
          echo "Fail threshold: ${PR_SIZE_FAIL} lines"

          if [ "$total" -gt "$PR_SIZE_FAIL" ]; then
            # Post a comment and fail
            gh pr comment "$pr_number" --repo "$repo" --body "$(cat <<EOF
          :x: **PR Size Guard — Too Large**

          This PR has **${total} lines changed** (+${additions} / -${deletions}), which exceeds the maximum of **${PR_SIZE_FAIL} lines**.

          Please break this into smaller PRs. Large PRs are harder to review and more likely to introduce bugs.
          EOF
            )"
            echo "::error::PR has ${total} lines changed, exceeding the limit of ${PR_SIZE_FAIL}"
            exit 1

          elif [ "$total" -gt "$PR_SIZE_WARN" ]; then
            # Post a warning comment but pass
            gh pr comment "$pr_number" --repo "$repo" --body "$(cat <<EOF
          :warning: **PR Size Guard — Large PR**

          This PR has **${total} lines changed** (+${additions} / -${deletions}), which exceeds the warning threshold of **${PR_SIZE_WARN} lines**.

          Consider breaking future changes into smaller PRs when possible.
          EOF
            )"
            echo "::warning::PR has ${total} lines changed, exceeding the warning threshold of ${PR_SIZE_WARN}"
          else
            echo "PR size is within limits."
          fi
